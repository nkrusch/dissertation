\documentclass[sigplan,screen,timestamp,%review,
nonacm]{acmart}
\usepackage{microtype}
\usepackage{xspace}
\usepackage{csquotes}
\input{latex/newcommands.tex}

% https://popl23.sigplan.org/home/CoqPL-2023
% Call for Presentations
%
% To foster open discussion of cutting edge research which can later be published in full conference proceedings, we will not publish papers from the workshop. However, presentations may be recorded and the videos may be made publicly available.
% Submission Details
% Submission page: https://coqpl23.hotcrp.com/
% Important Dates:
% Submission: Thursday, October 20, 2022
% Notification: Thursday, November 17, 2022
% The deadline for sending us your final version will be January 6.
% Workshop: Saturday, January 21, 2023
% Submissions for talks and demonstrations should be described in an extended abstract, between 1 and 2 pages in length (excluding bibliography). We suggest formatting the text using the two-column ACM SIGPLAN latex style (9pt font). Templates are available from the ACM SIGPLAN page: http://www.sigplan.org/Resources/Author.

% If accepted:
% - I think we could discuss pymwp at the end of section 2, 
% - We should say why we conjecture that proofs about loops will be the hardest,


\begin{document}
\author{Clément Aubert}
\orcid{0000-0001-6346-3043}
\affiliation{\institution{Augusta University} \city{Augusta} \country{USA}}
\email{aubert@math.cnrs.fr}

\author{Thomas Rubiano}
\affiliation{\institution{LIPN---UMR 7030 Université Sorbonne Paris Nord} \city{Paris} \country{France}}
\email{rubiano.thomas@gmail.com}

\author{Neea Rusch}
\orcid{0000-0002-7354-5330}
\affiliation{\institution{Augusta University} \city{Augusta} \country{USA}}
\email{nrusch@augusta.edu}

\author{Thomas Seiller}
\orcid{0000-0001-6313-0898}
\affiliation{\institution{LIPN---UMR 7030 Université Sorbonne Paris Nord} \institution{CNRS} \city{Paris} \country{France}}
\email{seiller@lipn.fr}

\title{Certifying Complexity Analysis}

\begin{abstract}
This work drafts a strategy that leverages the field of Implicit Computational Complexity to certify resource usage in imperative programs.
This original approach sidesteps some of the most common--and difficult--obstacles \enquote{traditional} complexity theory face when implemented in Coq.
\end{abstract}

\keywords{Implicit Computational Complexity, Automatic Complexity Analysis, Program Verification}

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10010124.10010138.10010142</concept_id>
       <concept_desc>Theory of computation~Program verification</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003777.10003787</concept_id>
       <concept_desc>Theory of computation~Complexity theory and logic</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Program verification}
\ccsdesc[500]{Theory of computation~Complexity theory and logic}

\maketitle

\section{Motivation}
\label{sec:motivation}

The ability to statically infer resource bounds of programs offers numerous benefits, \eg 
to insure safe memory usage.
Even more preferable if those guarantees are established with the rigor of formal verification,
because that increases confidence in the obtained analysis result and enables integration of complexity
analyses into larger formal developments.

% Complexity with Coq is hard.
Unfortunately, computational complexity is notoriously difficult to represent formally for several reasons.
In general, deriving a complexity bound for an arbitrary program is an undecidable problem. % Address comment of review #2D here?
In the area of complexity theory, \textcquote[p.~114]{Forster2020}{formalisations of even basic complexity-theoretic results are not available}, hindering certification attempts.

For practical complexity analyses, many existing techniques present methodological challenges if they require \eg program termination or inlining functions~\cite{carbonneaux2015}.
Therefore, a realistic pathway toward formal certification of a program's resource usage is narrow.
A few encouraging early results exist, and we discuss some of those in \autoref{sec:related}.
In this proposal we will sketch how a different approach, founded on Implicit Computational Complexity,
could sidestep some of the usual difficulties in implementing and verifying complexity analyses in Coq.

% ICC offers a way.
The field of Implicit Computational Complexity (ICC)~\cite{DalLago2012a} drives better understanding of complexity classes, but it
also guides the development of resources-aware languages and static source code analyzers.
The core idea is to bound resources \emph{while the program is being written (or type checked)} instead of measuring its resource usage afterwards on an abstract model of computation.
This can be done through \eg bounded recursion or using typing mechanisms.
The goal is to find a syntactical restriction or a type system such that a program can be written or typed only if it belongs to a particular complexity class.
ICC-based systems are often compositional and they offer more natural tools to write programs than theoretical models of computation used in complexity theory.
We speculate these combined properties could make ICC-approaches a conceivable pathway toward certified complexity and sketch a more detailed plan below.

\section{Preliminary Action Plan}  % Replace with a better title
\label{sec:plans}

We plan to formalize in Coq an ICC-based complexity analysis technique, the \emph{mwp-flow analysis}~\cite{Jones2009}\footnote{Where mwp stands for \emph{m}aximum, \emph{w}eak polynomial and \emph{p}olynomial, representing increasing growth rates of variables values.}.
We chose this method because its internal mechanics has been recently studied~\cite{Aubert2022b}, and by our assessment, it seems suitable for formalization in Coq.
As for Coq, it seems like the ideal target language because of its existing libraries and preliminary work--some of which are discussed in \autoref{sec:related}--, most notably related to compilers~\cite{Leroy2009}.

\subsection{Overview of \emph{mwp}-Flow Analysis}
\label{subsec:mwp}

% ICC offers a way of doing statyc analysis.
%This later view on complexity was used to design statyc analyzers of simple imperative programming languages.
%One of them, the \emph{mwp}-analysis~\cite{Jones2009}, uses matrices to record data flows between variables.
%If a variables depends \enquote{too strongly} on another, it risks to grow exponentially if used carelessly inside a loop, and the analysis detects it and flags it.
%As a result, a program can get assigned a type---a matrix---only if all the values in it are bounded by a polynomial in the inputs sizes.
The \emph{mwp}-flow analysis certifies polynomial bounds on the size of the values manipulated by
an imperative program.
While it does not ensure (or require) program termination, it provides a certificate guaranteeing that the program uses throughout its execution at
most a polynomial amount of space, and as a consequence that if it terminates, it will do so in polynomial time in the size of its inputs.

The analysis computes, for each program variable, a vector tracking how it depends on other variables.
The vector values are determined by applying the nondeterminitic rules of the sound \emph{mwp}-calculus to the commands of the program.
Those vectors are collected in a matrix.
A program is assigned a matrix only if all the values in it are bounded by a polynomial in the inputs sizes.
This technique is compositional, abstracts away \eg iteration bounds, and operates on
a memory-less imperative language, reminiscent of the \texttt{Imp} language from Software Foundations~\cite%[Imp:Simple Imperative Programs]
{softwarefoundation1}.

% Our plan
%This analysis offers many advantages compared to more traditional static analyzers: for instance, it is compositional, and returns a multi-variate growth bound, if one can be derived.
%It is also extremely fast, partly because it is not concerned with loop counters: the analysis is simply insensible to the loops' conditions.
%Those first encouraging results have been refined and implemented~\cite{pymwp,Aubert2022b,Aubert2022g,Aubert2022l}, and we believe they constitute an excellent path toward verifying resource bounds with Coq.

% What we have done.
%The original analysis~\cite{Jones2009} was computationally expensive and slow: our first efforts were geared toward, in parallel, stream-lining the theoretical construction~\cite{Aubert2022b} and implementing it~\cite{pymwp,Aubert2022l} to insure that our strategy was realistic.
%We are now in possession of a resilient and realistic static analyzer, whose correctness was reduced to the one of the original calculus~\cite{Jones2009}.
%We believe it is now time to certify this original calculus, whose main result states that a program can be assigned a matrix iff there is an honest polynomial bounding the growth-rate of its variables.

\subsection{The Coq Formalization}
\label{subsec:action-plan}

Our goal is to certify the analysis as presented in the original paper~\cite{Jones2009}.
Note that this does not mean that the bound is certified, but that \emph{the mechanism to compute those bounds} is certified.
Of course, this implies the correctness of the bounds as a by-product but constitutes a major difference \wrt the results discussed in \autoref{sec:related}.
%
Preliminary explorations have led us to establish the following milestones.

\begin{description}
	\item[The mathematical foundations]
		Our first goal is to define the mathematical structure required to carry out the rest of the construction.
        This requires defining vectors, matrices and their operations, semi-rings, and honest polynomials\footnote{Which are \textcquote[p.~5]{Jones2009}{polynomial build up from constants in $\mathbb{N}$ and variables by applying the operations $+$ (addition) and $\times$ (multiplication).}} that are
        needed to represent the \emph{mwp}-bounds.
        The Mathematical Components library~\cite{mathcomp} will lay the foundations for the linear algebra representations,
        but likely requires extensions to accommodate our specific analysis.

	\item[Implementing the language]
        The analyzed language is a simple imperative language that manipulates natural numbers,
        held in a fixed number of program variables. Its syntax includes
        variables, expressions (operations $+$ and $\times$), Boolean expressions, and commands (\eg  assignment, loop and decision statements, command sequences, and skip), with their usual semantics.
        We expect implementing it and its small-steps semantics in Coq to be relatively simple,
        following the examples from Software Foundations~\cite{softwarefoundation1,softwarefoundation2}.

	\item[Implementing the typing system]
		Even if it can be computationally expensive to run an automatic inference~\cite{Aubert2022l}, the typing system \emph{in itself} is relatively simple.
		It contains only 10 rules, essentially one for each type of command, and except for the initial assignment of vectors to variables, is fully deterministic.
		We conjecture that standard methods~\cite{Chiapala2022, Chlipala2010} to implement simple type systems will be enough, but will require some care to scale to the matrix-as-type paradigm of this analysis.	
	
	\item[Certifying the analysis]
		This will be the most demanding part of our plan.
        The original paper contains all the required handwritten proofs, but the authors caution that \enquote{\textins{t}hese proofs are long, technical and occasionally highly nontrivial}~\cite[p.~2]{Jones2009}. 
        The main result of the paper is the soundness proof of the analysis~\cite[Theorem 5.3]{Jones2009},
        \ie the proof of the existence of a matrix typing the program implies the existence of an honest polynomial bounding the variables' growth rates.
        The main result follows from 15 pages of proofs presented in section 7 of the paper.
        This section revolves around proving the soundness properties of the calculus,
        and we expect the most substantial effort to be spent on formalizing these proofs.
        Some of them are quite intricate but with a satisfactory level of detail.
		The cases concerning soundness of loops are the most difficult on paper, but their inductive nature \emph{should} (we hope!) be processed by Coq rather easily.%, in part because they require computing the fixpoint of matrices.
\end{description}

We leave for future work the possibility of creating a formally verified, automatic static analyzer founded on the proof of correctness of this method: as we discussed in other works~\cite{Aubert2022l,Aubert2022b}, care is required to implement a typing strategy that does not rapidly become intractable.

\section{Related Work}
\label{sec:related}

A few prior results exist that combine formalization of complexity and Coq.
They range from practical analyses to proofs in computational complexity theory.

For practical application, Coq has been used to verify stack bounds for assembly code~\cite{Carbonneaux2014}
and to obtain WCET loop-bound estimation~\cite{Blazy2013}.
Carbonneaux et al. ~\cite{Carbonneaux2017} presented an automatic static analyzer for imperative programs, and although the analyzer itself is not verified, it generates bounds with machine-checkable certificates, to guarantee that the computed bound holds.
For functional paradigm, McCarthy et al.~\cite{McCarthy2018} developed a Coq library, with a monad that counts abstract steps, which enabled running time analysis of programs written using the monad.
An ICC-based characterization was introduced by F\'{e}r\'{e}e et al.~\cite{Feree2018}, in the form of a
Coq library, that allows for readily proving that a function is computable in polynomial time. % Do something to clarify reviewer #2A here?

Coq has also been used to formalize some of the foundations of modern complexity theory.
Ciaffaglione~\cite{Ciaffaglione2016} proved the undecidability of the halting problem.
Gu{\'e}neau et al.~\cite{Gueneau2018} formalize the \(\mathcal{O}\) notation.
Forster et al.~\cite{Forster2020} implemented a multi-tape to single-tape compiler, and
introduced the first formalized universal Turing Machine verified \wrt time and space complexity, for any model of computation, in any proof assistant.
More recently, G\"{a}her and Kunze formalized the Cook-Levin theorem in Coq~\cite{Gaher2021}.
Despite these advances, formalization of complexity is in early stages and basic complexity-theoretic
results \eg time and space hierarchy theorems, remain unavailable.

Our proposed project differs from these earlier results primarily in its intent.
We plan to formalize the complexity analysis mechanism itself---not its computed result, as was done previously.
In their work with the Turing Machines, Forster et al.~\cite{Forster2020} were explicit
in emphasizing the challenge they experienced in formalizing complexity.
We hypothesize that our ICC-based approach, with \eg its built-in abstractions, will help reduce this challenge.
It is our hope that CoqPL will welcome our proposal for a certified complexity analysis in Coq, and will be keen on indicating any library, tool or resource that could help.

\begin{acks}
	The authors wish to thank \href{http://people.rennes.inria.fr/Delphine.Demange/}{Delphine Demange} for the interesting discussion she had with Neea, and the reviewers for their careful reading and many interesting comments.
	This research is supported by the \href{https://face-foundation.org/transatlantic-study-research/transatlantic-research-partnership/}{Th.\ Jefferson Fund} of the Embassy of France in the United States and the \href{https://face-foundation.org/}{FACE Foundation}, and has benefited from the research meeting \href{https://www.dagstuhl.de/de/programm/kalender/evhp/?semnr=21453}{21453 \enquote{Static Analyses of Program Flows: Types and Certificate for Complexity}} in Schloss Dagstuhl. Th.\ Rubiano and Th.\ Seiller are supported by the Île-de-France region through the DIM RFSI project \enquote{CoHOp}.
	N.\ Rusch is supported in part by the Augusta University Provost's office, and the \href{https://www.augusta.edu/mcg/medicine/research/trp/about-srp.php}{Translational Research Program} of the Department of Medicine, Medical College of Georgia at Augusta University.
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{bib/bib.bib}
\end{document}
