%! suppress = MissingLabel
%! suppress = NonBreakingSpace
\section{Applied Implicit Computational Complexity (Extended Abstract)}

The gold standard in formal verification is showing that a program (\ie an implementation), is \emph{totally correct}.
Total correctness requires proving two conditions.
The first is showing that the implementation meets its specification.
Typically, a specification is expressed in terms of \emph{functional} input/output behavior.
In other words, a correct program computes the expected output for all inputs.
The second condition is showing that the program terminates -- {eventually}.
An often-overlooked aspect concerns the so-called \emph{non-functional} properties.
Non-functional properties include features like execution latency and information security~\cite{terbeek2018}.
The significance of non-functional properties follows from the recognition that a functionally-correct program is \emph{practically} unsatisfactory,
if it operates in exponential time, or reveals secret information~\cite{heraud2011,aubert20222}.
Unfortunately, verifying non-functional properties is not straightforward.
Among the open challenges is how to express and model such properties~\cite{etaps2025}.

The field of {Implicit Computational Complexity (ICC)}~\cite{dallago2011} offers a conceivable pathway toward reasoning about certain non-functional properties.
Implicit computational complexity complements classical complexity theory by aiming to discover \emph{machine-independent} characterizations of complexity classes.
The complexity classes represent the resource requirements of computation.
They correspond in practice to, \eg program execution latency and memory consumption.
ICC systems are designed by introducing a \emph{restriction} at the level of a programming language.
Then, every program satisfying the restriction is known to belong to a particular complexity class~\cite{pchoux2020}.
Exchanging machine models for language-based criteria is powerful because it enables expressing syntactical specifications and developing fully \emph{automatable} program analyses~\cite{heraud2011}.
This way, we can obtain {guarantees} about runtime behavior, without manual assistance and without executing the program of interest.
ICC systems have been designed around various baseline techniques, including term rewriting, calculi, data flow analysis, type systems, \etc~\cite{baillot2012,moyen2017}

\subsection{Motivation, Problem Description, and Goals}

There are several good motivations for reasoning about complexity implicitly.
For example, ICC allows guaranteeing program properties by construction \emph{before} any program exists.
ICC drives better understanding of complexity classes and yields more natural definitions and proofs of central results than the classical approach~\cite{kristiansen2017}.
Among the systems, some are expressive enough to write down \emph{natural} algorithms, \eg~\cite{jones2009,marion2011}.
Since the reasoning techniques differ in their foundations, the analyses are often orthogonal to alternatives~\cite{aubert20222}.
Finally, many ICC systems are by design \emph{compositional}, \eg~\cite{jones2009,marion2011,hainry2023,atkey2024}.
Compositionality is critical for analysis scalability~\cite{carbonneaux2015}, and eases soundness proofs~\cite{keidel2021},
but is missed by many alternative static techniques~\cite{carbonneaux2015,schiebel2024}.

Despite the rich inventory of compelling features, unfortunately implicit computational complexity has remained primarily as a theoretical novelty;
with a few exceptions~\cite{avanzini2017,moyen20172,hoffmann2012,hainry2021}.
A theory in absence of applications means the potential, power, limitations, and utilities of the theory are difficult to recognize\footnote{
Reviewer \#2 might even call such theory \enquote{useless}.}.
In our view, theory and application are symbiotic, and mutual investigation of both is vital for scientific advancement~\cite[pg. xxxv]{bishop2003}~\cite[p. 75]{moyen2017}.

A kind of \emph{implicit manifesto} of this dissertation is that application is necessary to push forward our collective understanding of implicit computational complexity.
Potentially great power and utility is \enquote{locked} within these theoretical systems, but it remains an open problem to release it.
Investigations are needed, within the ICC community, to explore the practical capabilities of the existing techniques.
We must also expose the ICC techniques to broader research communities, to discover new use cases and to facilitate fruitful collaboration~\cite[p. 7]{moyen2017},

The work in this dissertation is only a small step toward these ambitious long-term goals.
The realistic expectations are technical and social, as follows.
\begin{enumerate*}
\item Extend {applied} capabilities of ICC-based techniques in automatic program analysis and verification.
\item Take ICC techniques a few steps closer to becoming a standard in real world development workflows.
\item Open discourse and highlight the relevance of applications within the ICC community.
\item Expose and generate interest in techniques of implicit computational complexity in broader research communities.
\end{enumerate*}
A guiding intuition is that, \emph{if applied}, implicit complexity could provide us practical methods for formal reasoning and verification of \emph{many} non-functional program properties.

\subsection{Hypothesis, Research Questions, and Approaches}
\label{subsec:research-goals}

To make the investigation more concrete, the dissertation defines a \emph{main hypothesis}.
\begin{quotation}
\noindent We question whether implicit computational complexity can offer utility when lifted outside the theoretical domain.
\end{quotation}
However, because the hypothesis is not \enquote{research paper-sized}, it must be broken down further.
The dissertation investigation is organized into smaller projects, along two disjoint tracks, that collectively challenge the main hypothesis.

\begin{description}
\item[\#1]
    The first series focuses on the \emph{flow calculus of mwp-bounds}~\cite{jones2009}.
    The flow calculus is a canonical instance of a theoretical ICC-system.
    Several research questions arise from the flow calculus.
    \begin{enumerate}
    \item (\aref{sec:fscd} and \autoref{sec:atva}) Is it possible to develop practical static program analysis based on it?
    \item (\autoref{sec:mwp-calc-formal}) Can we formally prove the soundness of the flow calculus?
    \item (\autoref{sec:postcond}) What are the extended use cases of the flow calculus?
    \end{enumerate}
\end{description}

The questions about the flow calculus are still conventional, in the sense that they focus on resource analysis.
In other words, given a complexity-theoretic technique, we \emph{should} be able to apply it for reasoning about resource usage properties\footnote{
Turns out this is not as straightforward as it seems, but that will be revealed in the manuscripts.}.
To be more innovative, another line of work is needed.

\begin{description}
\item[\#2]
    The second series concerns applying ICC toward tracking \emph{other} semantic program properties.
    The idea is to take an ICC-technique as a baseline, then see if the technique can be adjusted to a different use case.
    Here the base system stems from quasi-invariants~\cite{marion2000}, particularly as formulated in~\textcite{moyen20172}.
    We then ask the following questions about its \emph{extended} uses\footnote{
    Although posed here as \enquote{obvious} questions, a substantial step here is actually \emph{identifying} other research areas where ICC-based techniques \emph{might} offer benefit (like compilers, parallel programming, or language-based security). The second challenge is then delivering on that intuition.}.
    \begin{enumerate}
    \item (\autoref{sec:vmcai}) How to develop a program optimization to increase parallelization potential?
    \item (\autoref{sec:anytime}) How to use is to analyze programs information flow security properties?
    \end{enumerate}
    This line of work is different in the sense that we are no longer concerned with analyzing a complexity properties.
    Rather, we ask if there is something inherent in the \emph{technique} itself that makes it flexible enough to reason about other program properties.

\end{description}

The research questions reflect a kind of dynamic process of discovery --
for example, to investigate the applications of the flow calculus requires first to understand its theory deeply.
We can be satisfied that the questions adequately challenge the main hypothesis.
However, that we precisely focus on these questions, techniques, and domains was not predictable in advance.
Conceivably, many other relevant interesting questions remain (\cf~\autoref{future-ops}).
We limit this presentation to questions we were able to investigate.

% What new understanding, knowledge, methods, or technologies will this research generate?
% What artifacts (tools, theories, methods) will be produced?
% What experiments, prototypes, or studies need to be produced/executed?
% What is the validation strategy?
% How will it show the goal was reached?
% Arguments: Are you going to set up experiments to test these hypotheses?
% If so, how? What are the variables in these experiments?
% How do you plan to control these variables for an unbiased experimental result?
% If not, how else do you plan to convince the field that your hypotheses hold?

Because the work is application-oriented, it also expectedly yields software artifacts (\cf~\aref{app:sec:artifacts}).
Most notably, the flow calculus of mwp-bounds is implemented as an open source static analyzer,
\href{https://statycc.github.io/pymwp}{pymwp}~\cite{aubert2023b}, for analysis of C programs.

\subsection{Key Findings and Conclusions}
\label{subsec:results}

The investigations have lead to numerous discoveries.

\begin{itemize}

\item Among the specific approaches, we can now confirm that it is possible to implement the flow calculus of mwp-bounds.
However, the implementation is not obvious and requires careful tuning of the underlying mathematical framework (\aref{sec:fscd}).
But adjustment in turn introduces a new problem, and that problem was solved separately, years later (in \autoref{sec:postcond}).
At conclusion, the enhanced flow calculus is applicable and richer than the original system (\cf\autoref{subsec:res-mwp-bounds}).
This investigation demonstrates the relevance of applications.

\item Regarding the quasi-invariant based approaches, we now know that the technique can be applied to track other program properties.
Because it works seamlessly with \pr|while| loops, its application in loop transformations was particularly compelling as
\pr|while| loop constructs are outside the capabilities of related program optimizations.
The same system can be applied to track non-interference, which is a data/information flow property.
The fact that the same system work on two seemingly distant program properties is reminiscent of the Dependency Core Calculus~\cite{abadi1999b},
where different semantic properties are modelled as \emph{instances of dependency}.
This realization suggests that the ICC-based quasi-invariance technique---which is also based on analysis of data flows---possesses wider applicability than yet discovered in this dissertation.

\end{itemize}

Zooming out of individual projects, we can reflect on the main hypothesis.
The key \enquote{big picture} findings are threefold.
First, Based on the works on the flow calculus, ICC offers complementary and orthogonal techniques of automatic resource analysis.
However, since the techniques are approximative, convincing other communities of their relevance still remains a challenge.
The second demonstrated finding is that it is possible to adjust the techniques to track other semantic properties.
While this direction allows ICC techniques shine outside their usual domain, it requires that the demonstrated application is \emph{actually} relevant,
independent of the origin of the technique.
The final finding is projective and social.
By restricting the programming languages, ICC offers the potential to achieve desirable properties apriori, via language design.
thus, we can achieve guarantees before any program exists;
never having to run any post-analysis.
While the works in the dissertation did not directly investigate this question, we recognize it as a future goal.
Its attainability depends crucially on a community shift to view ICC in the broader context it offers.
and the continued exploration of the applied potential of ICC.
